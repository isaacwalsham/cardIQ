import os
import re
import json
import fitz  # PyMuPDF for PDF text extraction
from io import BytesIO

from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
from dotenv import load_dotenv
from openai import OpenAI
from werkzeug.utils import secure_filename

# reportlab (styled PDF)
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.platypus import (
    SimpleDocTemplate,
    Paragraph,
    Spacer,
    Table,
    TableStyle,
    KeepTogether,
)
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle

# ---------- env & app setup ----------
load_dotenv()

app = Flask(__name__)
# allow only your frontend in dev; replace with your deployed origin for production
CORS(app, resources={r"/*": {"origins": "http://localhost:3000"}})

# upload cap (10 MB)
app.config["MAX_CONTENT_LENGTH"] = 10 * 1024 * 1024

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# ---------- helpers ----------
def sanitize_text(text: str) -> str:
    """remove control chars to keep inputs clean"""
    return re.sub(r"[\x00-\x1f\x7f]", "", text or "")

def allowed_pdf(filename: str) -> bool:
    return bool(filename) and filename.lower().endswith(".pdf")

def extract_text_from_pdf(file_path: str) -> str:
    """pull text from a pdf with pymupdf"""
    out = []
    with fitz.open(file_path) as doc:
        for page in doc:
            out.append(page.get_text())
    return "\n".join(out)

# ---- styled PDF builder (grayscale, card boxes) ----
def build_flashcards_pdf(buffer: BytesIO, title: str, flashcards: list) -> None:
    """
    create a clean, grayscale pdf with boxed flashcards
    - big title
    - each card has a subtle border, padding, and Q/A layout
    - avoids splitting a single card across pages when possible
    """
    # document
    doc = SimpleDocTemplate(
        buffer,
        pagesize=letter,
        leftMargin=0.75 * inch,
        rightMargin=0.75 * inch,
        topMargin=0.85 * inch,
        bottomMargin=0.85 * inch,
        title=title or "CardIQ Flashcards",
        author="CardIQ",
    )

    # styles (grayscale)
    base = getSampleStyleSheet()
    title_style = ParagraphStyle(
        "Title",
        parent=base["Title"],
        fontName="Helvetica-Bold",
        fontSize=20,
        leading=24,
        textColor=colors.black,
        spaceAfter=12,
        alignment=1,  # centered
    )
    sub_style = ParagraphStyle(
        "Subtle",
        parent=base["Normal"],
        fontName="Helvetica",
        fontSize=10,
        leading=13,
        textColor=colors.grey,
        alignment=1,
        spaceAfter=12,
    )
    q_style = ParagraphStyle(
        "Question",
        parent=base["BodyText"],
        fontName="Helvetica-Bold",
        fontSize=12,
        leading=16,
        textColor=colors.black,
    )
    a_style = ParagraphStyle(
        "Answer",
        parent=base["BodyText"],
        fontName="Helvetica",
        fontSize=12,
        leading=16,
        textColor=colors.black,
    )

    story = []

    # title
    title_text = title.strip() if title and title.strip() else "CardIQ Flashcards"
    story.append(Paragraph(title_text, title_style))
    story.append(Paragraph("generated by CardIQ", sub_style))
    story.append(Spacer(1, 6))

    # build each flashcard as a KeepTogether(Table)
    # table has two rows: Q row (light grey bg), A row (white), with padding + border
    for idx, card in enumerate(flashcards, start=1):
        q = sanitize_text(str(card.get("question", "")).strip())
        a = sanitize_text(str(card.get("answer", "")).strip())

        q_para = Paragraph(f"Q{idx}: {q}", q_style)
        a_para = Paragraph(f"A: {a}", a_style)

        tbl = Table(
            [[q_para], [a_para]],
            colWidths=[doc.width],
            hAlign="LEFT",
            style=TableStyle(
                [
                    # outer box
                    ("BOX", (0, 0), (-1, -1), 0.75, colors.grey),
                    ("INNERGRID", (0, 0), (-1, -1), 0.25, colors.lightgrey),
                    # paddings
                    ("LEFTPADDING", (0, 0), (-1, -1), 10),
                    ("RIGHTPADDING", (0, 0), (-1, -1), 10),
                    ("TOPPADDING", (0, 0), (-1, -1), 8),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 10),
                    # backgrounds
                    ("BACKGROUND", (0, 0), (-1, 0), colors.whitesmoke),  # question row
                    ("BACKGROUND", (0, 1), (-1, 1), colors.white),       # answer row
                ]
            ),
        )

        story.append(KeepTogether([tbl]))
        story.append(Spacer(1, 10))

    doc.build(story)

# ---------- routes ----------
@app.route("/generate", methods=["POST"])
def generate_flashcards():
    try:
        text = ""
        file_path = None

        # text via JSON
        if request.is_json:
            data = request.get_json(silent=True) or {}
            text = sanitize_text(data.get("text", ""))

        # or pdf via form-data
        elif "file" in request.files:
            up = request.files["file"]
            if not up or not allowed_pdf(up.filename):
                return jsonify({"error": "Only PDF uploads are allowed."}), 400

            os.makedirs("uploads", exist_ok=True)
            safe_name = secure_filename(up.filename)
            file_path = os.path.join("uploads", safe_name)
            up.save(file_path)

            text = sanitize_text(extract_text_from_pdf(file_path))

        else:
            return jsonify({"error": "No input provided."}), 400

        # cleanup temp file
        if file_path and os.path.exists(file_path):
            try:
                os.remove(file_path)
            except Exception:
                pass

        if not text.strip():
            return jsonify({"error": "No text found."}), 400

        # call openai to generate flashcards
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": (
                        "You are a flashcard generator. "
                        "Return ONLY a valid JSON array of objects with 'question' and 'answer' string fields. "
                        'Example: [{"question":"What is X?","answer":"Y"}]'
                    ),
                },
                {"role": "user", "content": f"Generate flashcards from this text:\n{text}"},
            ],
        )

        raw = (resp.choices[0].message.content or "").strip()

        try:
            cards = json.loads(raw)
            if not isinstance(cards, list):
                raise ValueError("Model did not return a list")
        except Exception:
            # basic fallback: parse lines "Question? Answer ..."
            cards = []
            for line in raw.splitlines():
                if "?" in line:
                    q, _, rest = line.partition("?")
                    cards.append(
                        {"question": q.strip() + "?", "answer": rest.strip(" -:")}
                    )

        if not cards:
            return jsonify({"error": "Failed to generate flashcards."}), 500

        return jsonify(cards)

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route("/download", methods=["POST"])
def download_flashcards():
    """
    return a STYLED pdf (grayscale, boxed cards) built with reportlab
    expects: { flashcards: [...], filename?: "name to save as" }
    """
    try:
        data = request.get_json(silent=True) or {}
        flashcards = data.get("flashcards", [])
        filename = (data.get("filename") or "flashcards").strip()

        if not isinstance(flashcards, list) or len(flashcards) == 0:
            return jsonify({"error": "No flashcards provided."}), 400

        # build pdf into memory buffer
        buf = BytesIO()
        build_flashcards_pdf(buf, filename, flashcards)
        buf.seek(0)

        safe_download = secure_filename(f"{filename}.pdf")
        return send_file(
            buf,
            as_attachment=True,
            download_name=safe_download,
            mimetype="application/pdf",
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# ---------- main ----------
if __name__ == "__main__":
    app.run(debug=True)